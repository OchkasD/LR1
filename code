F = GF(2)
def get_parity_check_matrix(G_sys):
    k, n = G_sys.nrows(), G_sys.ncols()
    assert k + (n - k) == n, "Неверные размерности матрицы"
    P = G_sys[:, k:]
    P_T = P.transpose()

    I_nk = identity_matrix(GF(2), n - k)

    H = block_matrix([[P_T.augment(I_nk)]])
    return H

def make_bch_encoder(n, k):
    m = None
    for i in range(1, 50):
        if 2**i - 1 == n:
            m = i
            break
    if m is None:
        raise ValueError(f"n = {n} не равно 2^m - 1 ни при каком m")

    F.<a> = GF(2**m)
    alpha = F.primitive_element()

    P.<x> = PolynomialRing(GF(2))

    g = (alpha**1).minimal_polynomial()
    g = P(g)

    print(f"Параметры: n={n}, k={k}, m={m}, t=1")
    print("Порождающий многочлен:", g)

    G = matrix(GF(2), k, n)
    for i in range(k):
        poly = (x**i * g).mod(x**n - 1)
        coeffs = poly.list()
        row = [0] * n
        for j in range(len(coeffs)):
            row[j] = coeffs[j]
        G[i] = vector(GF(2), row)

    G = G.echelon_form()
    H = get_parity_check_matrix(G)
    
    return G, g, H, (G*H.T).is_zero()

def encoder(message, G):
    return message * G

def check_message(input_message, H):
    return (input_message * H.T).is_zero()

def build_syndrome_table(H, t):
    n = H.ncols()
    r = H.nrows()
    syndrome_table = {}

    for w in range(t + 1):
        for positions in Combinations(n, w):
            e = vector(F, n)
            for pos in positions:
                e[pos] = F(1)

            s = H * e.column()
            s_tuple = tuple(s[i, 0] for i in range(r))

            if s_tuple not in syndrome_table:
                syndrome_table[s_tuple] = vector(F, e)
                
    return syndrome_table

syndrome_table = build_syndrome_table(H, t=1)

def decode_message(y, H, syndrome_table, G):
    r = H.nrows()

    s = H * y.column()
    s_tuple = tuple(s[i, 0] for i in range(r))

    e_est = syndrome_table.get(s_tuple, None)
    if e_est is None:
        print("Ошибка: неизвестный синдром — ошибка не исправляется.")
        return None

    c_est = y + e_est

    k = G.nrows()
    n = G.ncols()
    for i in range(2 ** k):
        bits = bin(i)[2:].zfill(k)
        m = vector(F, [F(int(bit)) for bit in bits])
        if (m * G) == c_est:
            return m

    return None

n = 15
k = 10
G, g, H, matrix_result = make_bch_encoder(n, k)

print("Порождающая матрица G")
print(G)
print()
print("Проверочная матрица H")
print(H)
print()
print("Проверка G*H.T: ", matrix_result)

import random
m = vector(F, [F(random.randint(0, 1)) for _ in range(k)])
print("Исходное сообщение m:")
print(m)

c = encoder(m, G)
print("Кодовое слово c:")
print(c)

e = vector(F, n)
error_pos = random.randint(0, n - 1)
e[error_pos] = F(1)
y = c + e
print("Повреждённое слово y:")
print(y)

m_est = decode_message(y, H, syndrome_table, G)

if m_est is not None:
    print("Восстановленное сообщение m_est:")
    print(m_est)
    print("Сообщение восстановлено успешно:", m == m_est)
else:
    print("Ошибка: сообщение не восстановлено.")
